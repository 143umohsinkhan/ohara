package com.island.ohara.configurator.call

import java.util.concurrent.atomic.AtomicLong
import java.util.concurrent.{ConcurrentSkipListMap, Executors, TimeUnit}

import com.island.ohara.client.configurator.v0.ErrorApi
import com.island.ohara.client.configurator.v0.ErrorApi.Error
import com.island.ohara.common.data.Serializer
import com.island.ohara.common.util.{CommonUtil, ReleaseOnce}
import com.island.ohara.kafka.{Consumer, KafkaClient, Producer}
import com.typesafe.scalalogging.Logger
import org.apache.kafka.common.errors.WakeupException

import scala.concurrent._
import scala.concurrent.duration._
import scala.reflect.ClassTag

private[call] object CallQueueClientImpl {
  def apply[Request <: AnyRef, Response: ClassTag](
    brokers: String,
    requestTopic: String,
    responseTopic: String,
    pollTimeout: Duration,
    expirationCleanupTime: Duration): CallQueueClientImpl[Request, Response] = {
    // check topics
    val client = KafkaClient.of(brokers)
    try {
      def check(topicName: String): Unit =
        if (!client.exist(topicName)) throw new IllegalArgumentException(s"$topicName doesn't exist")
      check(requestTopic)
      check(responseTopic)
    } finally client.close()
    val uuid = CommonUtil.uuid()
    val producer = Producer.builder().brokers(brokers).build(Serializer.OBJECT, Serializer.OBJECT)
    val consumer = try Consumer
      .builder()
      .brokers(brokers)
      // the uuid from requestConsumer is random since we want to check all response.
      .groupId(uuid)
      .offsetAfterLatest()
      .topicName(responseTopic)
      .build(Serializer.OBJECT, Serializer.OBJECT)
    catch {
      case e: Throwable =>
        producer.close()
        throw e
    }
    new CallQueueClientImpl(requestTopic, responseTopic, pollTimeout, expirationCleanupTime, uuid, producer, consumer)
  }
}

/**
  * A request-> response based call queue. This implementation is based on kafka topic. It have a kafka consumer and a
  * kafka producer internally. The conumser is used to receive the RESPONSE or Error from call queue server.
  * The producer is used send the REQUEST to call queue server.
  *
  * @param pollTimeout           the specified waiting time elapses to poll the consumer
  * @param expirationCleanupTime the time to call the lease dustman
  * @tparam Request  the supported request type
  * @tparam Response the supported response type
  */
private class CallQueueClientImpl[Request <: AnyRef, Response: ClassTag] private (requestTopic: String,
                                                                                  responseTopic: String,
                                                                                  pollTimeout: Duration,
                                                                                  expirationCleanupTime: Duration,
                                                                                  uuid: String,
                                                                                  producer: Producer[AnyRef, AnyRef],
                                                                                  consumer: Consumer[AnyRef, AnyRef])
    extends CallQueueClient[Request, Response] {

  private[this] val logger = Logger(getClass.getName)

  /**
    * responseWorker thread + expiredRequestDustman thread
    */
  private[this] implicit val executor: ExecutionContextExecutorService =
    ExecutionContext.fromExecutorService(Executors.newFixedThreadPool(2))

  /**
    * We have to trace each request so we need a incrementable index.
    */
  private[this] val indexer = new AtomicLong(0)

  /**
    * store the response handler against the CallQueueResponse.
    * We use ConcurrentSkipListMap rather than ConcurrentHashMap because we need the method from polling the first element.
    */
  private[this] val responseReceivers = new ConcurrentSkipListMap[String, ResponseReceiver]()

  /**
    * 2) CallQueueResponse -> data
    * this group is generated by handler. It show that handler have done for the request, and it works. the response is passed
    * to the internal response handler used to accept the response and notify the user who is waiting for the response
    */
  private[this] val responseWorker = Future[Unit] {
    import collection.JavaConverters._
    try {
      while (!this.isClosed) {
        try {
          val records = consumer.poll(java.time.Duration.ofNanos(pollTimeout.toNanos)).asScala
          records
            .filter(_.topic == responseTopic)
            .foreach(record => {
              Option(record.key.orElse(null)).foreach {
                case internalResponse: CallQueueResponse =>
                  if (responseReceivers.containsKey(internalResponse.reqId)) {
                    Option(record.value.orElse(null)).foreach {
                      case response: Response =>
                        // NOTED: the uuid we record is CallQueueRequest'd uuid
                        responseReceivers.remove(internalResponse.reqId).complete(response)
                      case exception: Error =>
                        // NOTED: the uuid we record is CallQueueRequest'd uuid
                        responseReceivers.remove(internalResponse.reqId).complete(exception)
                      case _ => // this response is not for this client
                    }
                  }
                case _: CallQueueRequest => // This is call queue server's job
                case _ =>
                  logger.error(s"unsupported key. The supported key by call queue client is CallQueueResponse")
              }
            })
        } catch {
          case _: WakeupException => logger.debug("interrupted by ourself")
        }
      }
    } catch {
      case e: Throwable => logger.error("failure when running the responseWorker", e)
    } finally close()
  }

  private[this] def toError(e: Throwable) = ErrorApi.of(e)

  /**
    * used to notify the dustman to do its job
    */
  private[this] val notifierOfDustman = new Object
  private[this] val expiredRequestDustman = Future[Unit] {
    try {
      while (!isClosed) {
        try {
          import scala.collection.JavaConverters._
          val expiredNotifiers = responseReceivers.values().asScala.filter(_.isTimeout).toArray
          expiredNotifiers.foreach(notifier => {
            val expired = responseReceivers.remove(notifier.requestUuid)
            if (expired != null) {
              expired.complete(toError(CallQueue.EXPIRED_REQUEST_EXCEPTION))
            }
          })
          notifierOfDustman.synchronized {
            notifierOfDustman.wait(expirationCleanupTime.toMillis)
          }
        } catch {
          case _: InterruptedException => logger.debug("interrupt the dustman by ourself")
        }
      }
    } catch {
      case e: Throwable => logger.error("Failed to run the dustman", e)
    } finally close()

  }

  def wakeupDustman(): Unit = notifierOfDustman.synchronized {
    notifierOfDustman.notifyAll()
  }

  private[this] def requestUuid() = s"$uuid-request-${indexer.getAndIncrement()}"

  override def request(request: Request, timeout: Duration): Future[Either[Error, Response]] = {
    val lease = timeout + (CommonUtil.current() milliseconds)
    val internalRequest = CallQueueRequest(requestUuid(), lease)
    val receiver = new ResponseReceiver(internalRequest.uuid, lease)
    responseReceivers.put(internalRequest.uuid, receiver)
    try {
      producer.sender().key(internalRequest).value(request).send(requestTopic)
      producer.flush()
    } catch {
      case exception: Throwable => responseReceivers.remove(internalRequest.uuid).complete(toError(exception))
    }
    // an new request so it is time to invoke dustman to check the previous requests
    wakeupDustman()
    receiver.future
  }

  override protected def doClose(): Unit = {
    import scala.concurrent.duration._
    wakeupDustman()
    // release all notifiers
    Iterator
      .continually(responseReceivers.pollFirstEntry())
      .takeWhile(_ != null)
      .map(_.getValue)
      .foreach(_.complete(CallQueue.TERMINATE_TIMEOUT_EXCEPTION))
    if (consumer != null) consumer.wakeup()
    if (responseWorker != null) Await.result(responseWorker, 60 seconds)
    ReleaseOnce.close(consumer)
    ReleaseOnce.close(producer)
    if (expiredRequestDustman != null) Await.result(expiredRequestDustman, 60 seconds)
    if (executor != null) {
      executor.shutdownNow()
      executor.awaitTermination(60, TimeUnit.SECONDS)
    }
  }

  /**
    * Used to notify the request with a response or exception
    *
    * @param requestUuid the request uuid
    * @param lease       lease
    */
  private class ResponseReceiver(val requestUuid: String, lease: Duration) {
    private[this] val promise = Promise[Either[Error, Response]]()

    /**
      * complete the request with a response
      *
      * @param response response
      */
    def complete(response: Response): Unit = if (promise.isCompleted)
      throw new RuntimeException("You have completed this request")
    else promise success Right(response)

    /**
      * complete the request with a exception
      *
      * @param exception exception
      */
    def complete(exception: Error): Unit = if (promise.isCompleted)
      throw new RuntimeException("You have completed this request")
    else promise success Left(exception)

    /**
      * complete the request with a exception
      *
      * @param exception exception
      */
    def complete(exception: Throwable): Unit = complete(toError(exception))

    /**
      * @return true if this request is expired. false otherwise.
      */
    def isTimeout: Boolean = lease.toMillis <= CommonUtil.current()

    def future: Future[Either[Error, Response]] = promise.future
  }

}
