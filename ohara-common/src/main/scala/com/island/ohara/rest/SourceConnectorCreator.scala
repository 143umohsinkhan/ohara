package com.island.ohara.rest
import java.util.Objects

import com.island.ohara.config.{OharaConfig, OharaJson}

import scala.collection.mutable

/**
  * Used to config and run the source connector.
  */
abstract class SourceConnectorCreator {
  protected var name: String = _
  protected var clzName: String = _
  protected var topicName: String = _
  protected var taskMax: Int = -1
  protected var config: mutable.HashMap[String, String] = _
  protected var _disableKeyConverter: Boolean = false
  protected var _disableValueConverter: Boolean = false

  /**
    * config the key converter be org.apache.kafka.connect.converters.ByteArrayConverter. It is useful if the data in topic
    * your connector want to take is byte array and is generated by kafka producer. For example, the source is RowProducer,
    * and the target is RowSinkConnector.
    *
    * @return this one
    */
  def disableKeyConverter(): this.type = {
    this._disableKeyConverter = true
    this
  }

  /**
    * config the value converter be org.apache.kafka.connect.converters.ByteArrayConverter. It is useful if the data in topic
    * your connector want to take is byte array and is generated by kafka producer. For example, the source is RowProducer,
    * and the target is RowSinkConnector.
    *
    * @return this one
    */
  def disableValueConverter(): this.type = {
    this._disableValueConverter = true
    this
  }

  /**
    * config the converter be org.apache.kafka.connect.converters.ByteArrayConverter. It is useful if the data in topic
    * your connector want to take is byte array and is generated by kafka producer. For example, the source is RowProducer,
    * and the target is RowSinkConnector.
    *
    * @return this one
    */
  def disableConverter(): this.type = {
    this._disableKeyConverter = true
    this._disableValueConverter = true
    this
  }

  /**
    * set the connector name. It should be a unique name.
    * @param name connector name
    * @return this one
    */
  def name(name: String): this.type = {
    this.name = name
    this
  }

  /**
    * set the connector class. The class must be loaded in class loader otherwise it will fail to create the connector.
    * @param clz connector class
    * @return this one
    */
  def connectorClass(clzName: String): this.type = {
    this.clzName = clzName
    this
  }

  /**
    * set the topic in which you have interest.
    * @param topicName topic
    * @return this one
    */
  def topic(topicName: String): this.type = {
    this.topicName = topicName
    this
  }

  /**
    * the max number of sink task you want to create
    * @param taskMax max number of sink task
    * @return this one
    */
  def taskNumber(taskMax: Int): this.type = {
    this.taskMax = taskMax
    this
  }

  def config(key: String, value: String): this.type = {
    if (config == null) config = new mutable.HashMap[String, String]()
    config += (key -> value)
    this
  }

  /**
    * extra config passed to sink connector. This config is optional.
    * @param config config
    * @return this one
    */
  def config(config: Map[String, String]): this.type = {
    this.config = new mutable.HashMap[String, String]()
    this.config ++= config
    this
  }

  /**
    * send the request to create the sink connector.
    * @return this one
    */
  def run(): RestResponse = {
    checkArgument()
    val request = OharaConfig()
    val connectConfig = new mutable.HashMap[String, String]
    if (config != null) connectConfig ++= config
    request.set("name", name)
    connectConfig.put("connector.class", clzName)
    connectConfig.put("topic", topicName)
    connectConfig.put("tasks.max", taskMax.toString)
    if (_disableKeyConverter)
      connectConfig.put("key.converter", "org.apache.kafka.connect.converters.ByteArrayConverter")
    if (_disableValueConverter)
      connectConfig.put("value.converter", "org.apache.kafka.connect.converters.ByteArrayConverter")
    request.set("config", connectConfig.toMap)
    send("connectors", OharaJson(request.toJson.toString))
  }

  /**
    * send the request to kafka worker
    * @param cmd related path
    * @param body body
    * @return response
    */
  protected def send(cmd: String, body: OharaJson): RestResponse

  private[this] def checkArgument(): Unit = {
    Objects.requireNonNull(name)
    Objects.requireNonNull(clzName)
    Objects.requireNonNull(topicName)
    if (taskMax <= 0) throw new IllegalArgumentException(s"taskMax should be bigger than zero, current:$taskMax")
  }
}

object SourceConnectorCreator {
  def apply(restClient: BoundRestClient): SourceConnectorCreator = (cmd: String, body: OharaJson) =>
    restClient.post(cmd, body)
}
