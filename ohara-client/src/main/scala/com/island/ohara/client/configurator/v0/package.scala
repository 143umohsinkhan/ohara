/*
 * Copyright 2019 is-land
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.island.ohara.client.configurator

import com.island.ohara.common.data.{Cell, Row}
import com.island.ohara.common.setting.SettingDef.Type
import com.island.ohara.common.setting.{ConnectorKey, ObjectKey, PropGroup, SettingDef, TopicKey}
import com.island.ohara.common.util.CommonUtils
import spray.json.DefaultJsonProtocol._
import spray.json.{JsNull, JsValue, RootJsonFormat, _}

import scala.collection.JavaConverters._
import scala.concurrent.duration._
package object v0 {

  /**
    * Our first version of APIs!!!
    */
  val V0: String = "v0"

  /**
    * the default group to all objects.
    * the group is useful to Ohara Manager. However, in simple case, the group is a bit noisy so we offer the default group to all objects when
    * input group is ignored.
    */
  val GROUP_DEFAULT: String = "default"
  val GROUP_KEY: String = "group"

  /**
    * All services are able to bind a port to provide access.
    */
  val CLIENT_PORT_KEY = "clientPort"

  /**
    * All services are able to bind a port to provide metrics access.
    */
  val JMX_PORT_KEY = "jmxPort"

  /**
    * Noted: there are other two definition having "name"
    * 1) ConnectorDefUtils.CONNECTOR_NAME_DEFINITION
    * 2) StreamDefinitions.NAME_DEFINITION
    */
  val NAME_KEY: String = "name"

  val LAST_MODIFIED_KEY: String = "lastModified"

  /**
    * Noted: there are other two definition having "tags""
    * 1) ConnectorDefUtils.TAGS_DEFINITION
    * 2) StreamDefinitions.TAGS_DEFINITION
    */
  val TAGS_KEY: String = "tags"

  /**
    * Noted: there are other two definition having "nodeNames""
    * 1) StreamDefinitions.NODE_NAMES_DEFINITION
    */
  val NODE_NAMES_KEY: String = "nodeNames"
  val IMAGE_NAME_KEY: String = "imageName"
  val FORCE_KEY: String = "force"
  val START_COMMAND: String = "start"
  val STOP_COMMAND: String = "stop"
  val PAUSE_COMMAND: String = "pause"
  val RESUME_COMMAND: String = "resume"

  /**
    * There is no length limit for docker container name in current support version (18.09), but the k8s
    * docs did say that the maximum length is 253:
    * <p>https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    * <p>
    * We prefer to limit the sum of length with group and name since it will give us more flexibility.
    * It is worth to note that although we only restrict the "sum length", name and group fields should not
    * be empty since we forbid the empty string.
    * The length set to 100 here is enough for most case to set their group and name (each could has most 50 chars)
    */
  val LIMIT_OF_KEY_LENGTH: Int = 100

  /**
    * In this APIs we have to integrate json format between scala (spray-json) and java (jackson).
    * The JsNull generated by spray-json confuse jackson to generate many "null" object. We remove the key related to
    * JsNull in order to avoid passing null to jackson.
    */
  private[v0] def noJsNull(fields: Map[String, JsValue]): Map[String, JsValue] = fields.filter {
    _._2 match {
      case JsNull => false
      case _      => true
    }
  }

  private[v0] def noJsNull(jsValue: JsValue): Map[String, JsValue] = noJsNull(jsValue.asJsObject.fields)

  private[v0] implicit val OBJECT_KEY_FORMAT: RootJsonFormat[ObjectKey] = JsonRefiner[ObjectKey]
    .format(new RootJsonFormat[ObjectKey] {
      override def write(obj: ObjectKey): JsValue = ObjectKey.toJsonString(obj).parseJson
      override def read(json: JsValue): ObjectKey = json match {
        case JsString(s) => ObjectKey.of(GROUP_DEFAULT, s)
        case JsObject(fields) =>
          val group = noJsNull(fields)
            .get(GROUP_KEY)
            .map {
              case JsString(s) => s
              case _ =>
                throw DeserializationException(s"the type of $GROUP_KEY must be string", fieldNames = List(GROUP_KEY))
            }
            .getOrElse(GROUP_DEFAULT)
          val name = noJsNull(fields).getOrElse(NAME_KEY,
                                                throw DeserializationException(s"$NAME_KEY is required field",
                                                                               fieldNames = List(NAME_KEY))) match {
            case JsString(s) => s
            case _ =>
              throw DeserializationException(s"the type of $NAME_KEY must be string", fieldNames = List(NAME_KEY))
          }
          if (group.isEmpty) throw DeserializationException(s"$GROUP_KEY can't be empty", fieldNames = List(GROUP_KEY))
          if (name.isEmpty) throw DeserializationException(s"$NAME_KEY can't be empty", fieldNames = List(NAME_KEY))
          ObjectKey.of(group, name)
        case _ =>
          throw DeserializationException(
            "the form of key must be {\"group\": \"g\", \"name\": \"n\"}, {\"name\": \"n\"} or pure string")
      }
    })
    .nullToString(GROUP_KEY, () => GROUP_DEFAULT)
    .rejectEmptyString()
    .refine

  private[v0] implicit val TOPIC_KEY_FORMAT: RootJsonFormat[TopicKey] = new RootJsonFormat[TopicKey] {
    override def write(obj: TopicKey): JsValue = TopicKey.toJsonString(obj).parseJson
    override def read(json: JsValue): TopicKey = {
      // reuse the rules of ObjectKey
      val key = OBJECT_KEY_FORMAT.read(json)
      TopicKey.of(key.group(), key.name())
    }
  }

  private[v0] implicit val CONNECTOR_KEY_FORMAT: RootJsonFormat[ConnectorKey] = new RootJsonFormat[ConnectorKey] {
    override def write(obj: ConnectorKey): JsValue = ConnectorKey.toJsonString(obj).parseJson
    override def read(json: JsValue): ConnectorKey = {
      // reuse the rules of ObjectKey
      val key = OBJECT_KEY_FORMAT.read(json)
      ConnectorKey.of(key.group(), key.name())
    }
  }

  private[v0] implicit val PROP_GROUP_FORMAT: RootJsonFormat[PropGroup] = new RootJsonFormat[PropGroup] {
    override def write(obj: PropGroup): JsValue = JsArray(
      obj
        .raw()
        .asScala
        .map(_.asScala.map {
          case (key, value) => key -> JsString(value)
        }.toMap)
        .map(JsObject(_))
        .toVector)
    override def read(json: JsValue): PropGroup = try PropGroup.ofJson(json.toString())
    catch {
      case e: Throwable =>
        throw DeserializationException(s"failed to convert $json to PropGroup", e)
    }
  }

  /**
    * exposed to configurator
    */
  private[v0] implicit val SETTING_DEFINITION_JSON_FORMAT: RootJsonFormat[SettingDef] =
    new RootJsonFormat[SettingDef] {
      override def read(json: JsValue): SettingDef = SettingDef.ofJson(json.toString())
      override def write(obj: SettingDef): JsValue = obj.toJsonString.parseJson
    }

  private[v0] implicit val DURATION_JSON_FORMAT: RootJsonFormat[Duration] =
    new RootJsonFormat[Duration] {
      override def read(json: JsValue): Duration = json match {
        case JsString(s) =>
          try CommonUtils.toDuration(s).toMillis milliseconds
          catch {
            case _: Throwable =>
              throw DeserializationException(s"the value must be duration value, actual:$s")
          }
        case _ => throw DeserializationException(s"must be string type, actual:${json.getClass.getName}")
      }

      override def write(obj: Duration): JsValue = JsString(obj.toString)
    }

  /**
    * use basic check rules of object key for json refiner:
    * <p> 1) name and group must satisfy the regex [a-z0-9]
    * <p> 2) name will use randomString if not defined.
    * <p> 3) group will use defaultGroup if not defined.
    * <p> 4) name length + group length <= LIMIT_OF_KEY_LENGTH
    *
    * @tparam T type of object
    * @return json refiner object
    */
  private[v0] def rulesOfKey[T]: JsonRefiner[T] =
    limitsOfKey[T]
    // we random a default name for this object
      .nullToString(NAME_KEY, () => CommonUtils.randomString(LIMIT_OF_KEY_LENGTH / 2))
      .nullToString(GROUP_KEY, () => GROUP_DEFAULT)

  /**
    * add limits to group and name.
    * @return refiner
    */
  private[v0] def limitsOfKey[T]: JsonRefiner[T] =
    JsonRefiner[T]
    // we random a default name for this object
      .stringRestriction(Set(NAME_KEY, GROUP_KEY))
      .withNumber()
      .withLowerCase()
      .toRefiner
      // the sum of length: name + group <= LIMIT_OF_KEY_LENGTH
      .stringSumLengthLimit(Set(NAME_KEY, GROUP_KEY), LIMIT_OF_KEY_LENGTH)

  /**
    * use basic check rules of creation request for json refiner.
    * 1) reject any empty string.
    * 2) nodeName cannot use "start" and "stop" keywords.
    * 3) nodeName cannot be empty array.
    * 4) imageName will use {defaultImage} if not defined.
    * 5) tags will use empty map if not defined.
    * @tparam T type of creation
    * @return json refiner object
    */
  private[v0] def rulesOfCreation[T <: ClusterCreation](format: RootJsonFormat[T],
                                                        definitions: Seq[SettingDef]): OharaJsonFormat[T] =
    limitsOfKey[T]
      .format(format)
      .definitions(definitions)
      // for each field, we should reject any empty string
      .rejectEmptyString()
      //-------------------------------------- "nodeNames" rules ---------------------------------//
      // nodeNames is the only required field in creating cluster, add the requirement for it
      .requireKey(NODE_NAMES_KEY)
      .arrayRestriction(NODE_NAMES_KEY)
      // we use the same sub-path for "node" and "actions" urls:
      // xxx/cluster/{name}/{node}
      // xxx/cluster/{name}/[start|stop]
      // the "actions" keywords must be avoided in nodeNames parameter
      .rejectKeyword(START_COMMAND)
      .rejectKeyword(STOP_COMMAND)
      // the node names can't be empty
      .rejectEmpty()
      .toRefiner
      .refine

  /**
    * use basic check rules of update request for json refiner.
    * 1) reject any empty string.
    * 2) nodeName cannot use "start" and "stop" keywords.
    * 3) nodeName cannot be empty array.
    * @tparam T type of update
    * @return json refiner object
    */
  private[v0] def rulesOfUpdating[T <: ClusterUpdating](format: RootJsonFormat[T]): OharaJsonFormat[T] =
    JsonRefiner[T]
      .format(format)
      // for each field, we should reject any empty string
      .rejectEmptyString()
      //-------------------------------------- "nodeNames" rules ---------------------------------//
      .arrayRestriction(NODE_NAMES_KEY)
      // we use the same sub-path for "node" and "actions" urls:
      // xxx/cluster/{name}/{node}
      // xxx/cluster/{name}/[start|stop]
      // the "actions" keywords must be avoided in nodeNames parameter
      .rejectKeyword(START_COMMAND)
      .rejectKeyword(STOP_COMMAND)
      // the node names can't be empty
      .rejectEmpty()
      .toRefiner
      .refine

  /**
    * there are many objects containing "settings", and it is filterable so we separate the related code for reusing.
    *
    * @param settings settings
    * @param key key
    * @param value string of json representation. Noted the string of json string is pure "string" (no quote)
    * @return true if the key-value is matched. Otherwise, false
    */
  def matchSetting(settings: Map[String, JsValue], key: String, value: String): Boolean = settings.get(key).exists {
    // it is impossible to have JsNull since our json format does a great job :)
    case JsString(s)  => s == value
    case JsNumber(i)  => i == BigDecimal(value)
    case JsBoolean(b) => b == value.toBoolean
    case js: JsArray =>
      value.parseJson match {
        case other: JsArray => other == js
        case _              => false
      }
    case js: JsObject =>
      value.parseJson match {
        case other: JsObject => other == js
        case _               => false
      }
    case _ => false
  }

  /**
    * Compare the optional argument.
    *
    * Noted that it returns true if the optionString is empty and the query value is "none"
    * Noted that the comparison is case-insensitive
    * @param optionString option argument
    * @param value query value
    * @return true if matched. Otherwise, false
    */
  def matchOptionString(optionString: Option[String], value: String): Boolean =
    optionString.exists(_.toLowerCase == value.toLowerCase) || (optionString.isEmpty && value.toLowerCase == "none")

  private[this] def toJson(value: Any): JsValue = value match {
    //--------[primitive type]--------//
    case b: Boolean     => JsBoolean(b)
    case s: String      => JsString(s)
    case i: Short       => JsNumber(i)
    case i: Int         => JsNumber(i)
    case i: Long        => JsNumber(i)
    case i: Float       => JsNumber(i)
    case i: Double      => JsNumber(i)
    case _: Array[Byte] => JsString("binary data")
    case b: Byte        => JsNumber(b)
    //--------[for scala]--------//
    case i: BigDecimal  => JsNumber(i)
    case s: Iterable[_] => JsArray(s.map(toJson).toVector)
    //--------[ohara data]--------//
    case c: Cell[_] => JsObject(c.name() -> toJson(c.value()))
    case r: Row     => toJson(r)
    //--------[for java]--------//
    case i: java.math.BigDecimal  => JsNumber(i)
    case s: java.lang.Iterable[_] => JsArray(s.asScala.map(toJson).toVector)
    //--------[other]--------//
    case _ => throw new IllegalArgumentException(s"${value.getClass.getName} is unsupported!!!")
  }

  /**
    * convert the row to json representation.
    * This is a common conversion in Ohara since it is the bridge between http and data in topic.
    * @param row row
    * @return json representation
    */
  def toJson(row: Row): JsObject = JsObject(
    row.cells().asScala.map(cell => cell.name() -> toJson(cell.value())).toMap + (TAGS_KEY -> JsArray(
      row.tags().asScala.map(JsString(_)).toVector))
  )

  private[this] def toValue(value: JsValue): Any = value match {
    case JsNull       => throw new IllegalArgumentException("null should be eliminated")
    case JsBoolean(b) => b
    case JsNumber(i)  => i
    case JsString(s)  => s
    case JsArray(es) =>
      es.filter {
          case JsNull => false
          case _      => true
        }
        .map(toValue)
        .toList
    case obj: JsObject => toRow(obj)
  }

  /**
    * convert the json representation to row.
    * This is a common conversion in Ohara since it is the bridge between http and data in topic.
    * @param obj json represention
    * @return row
    */
  def toRow(obj: JsObject): Row = Row.of(
    noJsNull(obj.fields)
      .get(TAGS_KEY)
      .map {
        case s: JsArray => s
        case _          => throw DeserializationException(s"$TAGS_KEY must be array type", fieldNames = List(TAGS_KEY))
      }
      .map(_.elements.map(_.convertTo[String]))
      .getOrElse(Seq.empty)
      .asJava,
    noJsNull(obj.fields.filter(_._1 != TAGS_KEY)).map {
      case (name, value) =>
        Cell.of(name, toValue(value))
    }.toSeq: _*
  )

  //------------------[quick builder for cluster services]------------------//
  private[v0] def groupDefinition: SettingDef.Builder => SettingDef =
    _.key(GROUP_KEY).documentation("group of this worker cluster").optional(GROUP_DEFAULT).build()

  private[v0] def nameDefinition: SettingDef.Builder => SettingDef =
    _.key(NAME_KEY).documentation("name of this worker cluster").stringWithRandomDefault().build()

  private[v0] def imageNameDefinition(defaultImage: String): SettingDef.Builder => SettingDef =
    _.key(IMAGE_NAME_KEY).optional(defaultImage).documentation("the docker image of this service").build()

  private[v0] def clientPortDefinition: SettingDef.Builder => SettingDef =
    _.key(CLIENT_PORT_KEY).documentation("the port used to expose the service").bindingPortWithRandomDefault().build()

  private[v0] def jmxPortDefinition: SettingDef.Builder => SettingDef =
    _.key(JMX_PORT_KEY)
      .documentation("the port used to expose the metrics of this cluster")
      .bindingPortWithRandomDefault()
      .build()

  private[v0] def nodeDefinition: SettingDef.Builder => SettingDef =
    _.key(NODE_NAMES_KEY)
      .documentation("the nodes hosting this cluster")
      .blacklist(Seq(START_COMMAND, STOP_COMMAND, PAUSE_COMMAND, RESUME_COMMAND).asJava)
      .build()

  private[v0] def tagDefinition: SettingDef.Builder => SettingDef =
    _.key(TAGS_KEY).documentation("the tags to this cluster").optional(Type.TAGS).build()
}
