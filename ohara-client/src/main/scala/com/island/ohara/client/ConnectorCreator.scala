/*
 * Copyright 2019 is-land
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.island.ohara.client
import java.util.Objects

import com.island.ohara.client.ConnectorJson.{CreateConnectorRequest, CreateConnectorResponse}
import com.island.ohara.common.data.Column
import com.typesafe.scalalogging.Logger

import scala.collection.JavaConverters._
import scala.collection.mutable

/**
  * a base class used to collect the config from source/sink connector when creating
  */
abstract class ConnectorCreator {
  private[this] var name: String = _
  private[this] var clzName: String = _
  private[this] var topicNames: Seq[String] = _
  private[this] var numberOfTasks: Int = 1
  private[this] var config: mutable.HashMap[String, String] = _
  private[this] var _disableKeyConverter: Boolean = false
  private[this] var _disableValueConverter: Boolean = false
  private[this] var schema: Seq[Column] = Seq.empty

  /**
    * config the key converter be org.apache.kafka.connect.converters.ByteArrayConverter. It is useful if the data in topic
    * your connector want to take is byte array and is generated by kafka producer. For example, the source is RowProducer,
    * and the target is RowSinkConnector.
    *
    * @return this one
    */
  def disableKeyConverter(): this.type = {
    this._disableKeyConverter = true
    this
  }

  /**
    * config the value converter be org.apache.kafka.connect.converters.ByteArrayConverter. It is useful if the data in topic
    * your connector want to take is byte array and is generated by kafka producer. For example, the source is RowProducer,
    * and the target is RowSinkConnector.
    *
    * @return this one
    */
  def disableValueConverter(): this.type = {
    this._disableValueConverter = true
    this
  }

  /**
    * config the converter be org.apache.kafka.connect.converters.ByteArrayConverter. It is useful if the data in topic
    * your connector want to take is byte array and is generated by kafka producer. For example, the source is RowProducer,
    * and the target is RowSinkConnector.
    *
    * @return this one
    */
  def disableConverter(): this.type = {
    this._disableKeyConverter = true
    this._disableValueConverter = true
    this
  }

  /**
    * set the connector name. It should be a unique name.
    *
    * @param name connector name
    * @return this one
    */
  def name(name: String): this.type = {
    this.name = name
    this
  }

  /**
    * set the connector class. The class must be loaded in class loader otherwise it will fail to create the connector.
    *
    * @param clz connector class
    * @return this one
    */
  def connectorClass(clzName: String): this.type = {
    this.clzName = clzName
    this
  }

  /**
    * set the connector class. The class must be loaded in class loader otherwise it will fail to create the connector.
    *
    * @param clz connector class
    * @return this one
    */
  def connectorClass[T](clz: Class[T]): this.type = {
    this.clzName = clz.getName
    this
  }

  /**
    * set the topic in which you have interest.
    *
    * @param topicName topic
    * @return this one
    */
  def topic(topicName: String): this.type = {
    this.topicNames = Seq(topicName)
    this
  }

  /**
    * the max number from sink task you want to create
    *
    * @param numberOfTasks max number from sink task
    * @return this one
    */
  def numberOfTasks(numberOfTasks: Int): this.type = {
    this.numberOfTasks = numberOfTasks
    this
  }

  def config(key: String, value: String): this.type = {
    if (config == null) config = new mutable.HashMap[String, String]()
    config += (key -> value)
    this
  }

  /**
    * extra config passed to sink connector. This config is optional.
    *
    * @param config config
    * @return this one
    */
  def configs(config: Map[String, String]): this.type = {
    this.config = new mutable.HashMap[String, String]()
    this.config ++= config
    this
  }

  /**
    * set the schema
    * @param schema schema
    * @return this builder
    */
  def schema(schema: Seq[Column]): this.type = {
    this.schema = schema
    this
  }

  /**
    * set the topics in which you have interest.
    *
    * @param topicNames topics
    * @return this one
    */
  def topics(topicNames: Seq[String]): this.type = {
    this.topicNames = topicNames
    this
  }

  /**
    * send the request to create the sink connector.
    *
    * @return this one
    */
  def create(): CreateConnectorResponse = {
    checkArgument()
    if (config == null) config = new mutable.HashMap[String, String]()
    config += ("connector.class" -> clzName)
    config += ("topics" -> topicNames.mkString(","))
    config += ("tasks.max" -> numberOfTasks.toString)
    if (schema != null && schema.nonEmpty) config += (Column.COLUMN_KEY -> Column.fromColumns(schema.asJava))
    if (_disableKeyConverter) config += ("key.converter" -> "org.apache.kafka.connect.converters.ByteArrayConverter")
    if (_disableValueConverter)
      config += ("value.converter" -> "org.apache.kafka.connect.converters.ByteArrayConverter")
    // NOTED: If configs.name exists, kafka will use it to replace the outside name.
    // for exampe: {"name":"abc", "configs":{"name":"c"}} is converted to map("name", "c")...
    // Hence, we have to filter out the name here...
    config.remove("name").foreach(v => ConnectorCreator.LOG.error(s"(name, $v) is removed from configs"))
    send(CreateConnectorRequest(name, config.toMap))
  }

  /**
    * send the request to kafka worker
    *
    * @return response
    */
  protected def send(request: CreateConnectorRequest): CreateConnectorResponse

  protected def checkArgument(): Unit = {
    Objects.requireNonNull(name)
    Objects.requireNonNull(clzName)
    Objects.requireNonNull(topicNames)
    if (topicNames.isEmpty) throw new IllegalArgumentException(s"You must specify 1+ topic names")
    if (numberOfTasks <= 0)
      throw new IllegalArgumentException(s"taskMax should be bigger than zero, current:$numberOfTasks")
  }
}

object ConnectorCreator {
  private lazy val LOG = Logger(ConnectorCreator.getClass)
}
